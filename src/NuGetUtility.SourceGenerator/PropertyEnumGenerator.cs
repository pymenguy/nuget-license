// Licensed to the projects contributors.
// The license conditions are provided in the LICENSE file located in the project root

using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using NuGetUtility.SourceGenerator.Attributes;
using Pro.Common.SourceGenerator.Extensions;
using Pro.Common.SourceGenerator.Model;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace Pro.Common.SourceGenerator
{
    [Generator(LanguageNames.CSharp)]
    public sealed class PropertyEnumGenerator : IIncrementalGenerator
    {
        /// <inheritdoc/>
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            IncrementalValuesProvider<INamedTypeSymbol> allAnnotatedClasses =
                context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    typeof(GeneratePropertyEnumAttribute).FullName,
                    static (node, _) => true,
                    static (context, token) =>
                    {
                        if (context.TargetSymbol is INamedTypeSymbol namedSymbol)
                        {
                            return namedSymbol;
                        }
                        return null;
                    }).Where(s => s is not null).Select((s, _) => s!);

            IncrementalValuesProvider<(INamedTypeSymbol Symbol, IEnumerable<(string Name, string Description)> Values)> enums =
                allAnnotatedClasses.Select(static (m, _) =>
                {
                    IEnumerable<IPropertySymbol> properties = m.GetMembers().OfType<IPropertySymbol>();

                    IEnumerable<(string EnumName, string Description)> propertiesToGenerate =
                        properties.Where(p => p.HasAttributeWithFullyQualifiedMetadataName(typeof(PropertyDescriptionAttribute).FullName))
                        .SelectMany(p => GetEnumNameAndDescription(p));

                    return (m, Values: propertiesToGenerate.Select(p => (p.EnumName, p.Description)));
                });

            IncrementalValuesProvider<(string FileNameHint, CompilationUnitSyntax CompilationUnit)> enumModels = enums.Select(static (m, _) =>
            {
                string enumName = $"{m.Symbol.Name}Properties";
                CompilationUnitSyntax enumDeclaration = CompilationUnit().AddMembers(
                    NamespaceDeclaration(
                        IdentifierName(m.Symbol.ContainingNamespace.ToDisplayString()))
                        .WithLeadingTrivia(TriviaList(Comment("/// <auto-generated/>")))
                        .AddMembers(
                            EnumDeclaration(enumName)
                                .AddModifiers(Token(SyntaxKind.PublicKeyword))
                                .AddMembers(m.Values.Select(v => EnumMemberDeclaration(v.Name)).ToArray())
                                .AddGeneratedCodeAttribute(),
                            ClassDeclaration($"{enumName}Extension")
                                .AddModifiers(Token(SyntaxKind.PublicKeyword), Token(SyntaxKind.StaticKeyword))
                                .AddMembers(
                                    MethodDeclaration(ParseTypeName("string"), "GetDescription")
                                    .AddModifiers(Token(SyntaxKind.PublicKeyword), Token(SyntaxKind.StaticKeyword))
                                    .WithParameterList(ParameterList(SingletonSeparatedList(Parameter(Identifier("value")).WithType(ParseTypeName(enumName)).AddModifiers(Token(SyntaxKind.ThisKeyword)))))
                                    .WithBody(Block(
                                        SwitchStatement(IdentifierName("value"))
                                        .WithSections(List(m.Values.Select(v => SwitchSection()
                                                                                .WithLabels(SingletonList<SwitchLabelSyntax>(CaseSwitchLabel(IdentifierName($"{enumName}.{v.Name}"))))
                                                                                .AddStatements(ParseStatement($"return \"{v.Description}\";")))))
                                        .AddSections(SwitchSection()
                                                     .AddLabels(DefaultSwitchLabel())
                                                     .AddStatements(ParseStatement("throw new System.ArgumentException(\"The value {value} is not handled. This should never happen.\", \"value\");")))))))
                    .NormalizeWhitespace());

                var hierarchyInfo = HierarchyInfo.From(m.Symbol);

                return (FileNameHint: hierarchyInfo.FilenameHint, CompilationUnit: enumDeclaration);
            });

            context.RegisterSourceOutput(enumModels, static (context, item) =>
            {
                context.AddSource($"{item.FileNameHint}.Properties.g.cs", item.CompilationUnit.GetText(Encoding.UTF8));
            });
        }

        private static IEnumerable<(string EnumName, string Description)> GetEnumNameAndDescription(IPropertySymbol property)
        {
            string description = property.GetAttributes().Select(a => (a.AttributeClass?.HasFullyQualifiedMetadataName(typeof(PropertyDescriptionAttribute).FullName) == true) &&
                                                                   a.TryGetConstructorArgument(0, out string? description) ? description : null)
                                                      .First(d => !string.IsNullOrEmpty(d))!;
            yield return (EnumName: property.Name, Description: description);
        }
    }
}
